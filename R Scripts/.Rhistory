port <- add.constraint(port, type = "box", min = 0.05, max = 0.8)
port <- add.constraint(portfolio = port, type = "full_investment")
rportfolios <- random_portfolios(port, permutations = 5000, rp_method = "sample")
minvar.port <- add.objective(port, type = "risk", name = "var")
minvar.opt <- optimize.portfolio(returns.data, minvar.port, optimize_method = "random", rp = rportfolios)
maxret.port <- add.objective(port, type = "return", name = "mean")
maxret.opt <- optimize.portfolio(returns.data, maxret.port, optimize_method = "random", rp = rportfolios)
minret <- 0.06/100
maxret <- maxret.opt$weights %*% meanReturns
vec <- seq(minret, maxret, length.out = 100)
ff.frontier <- data.frame(Risk = rep(NA, length(vec)),
Return = rep(NA, length(vec)),
SharpeRatio = rep(NA, length(vec)))
frontier.weights <- mat.or.vec(nr = length(vec), nc = ncol(returns.data))
colnames(frontier.weights) <- colnames(returns.data)
for(i in 1:length(vec)){
eff.port <- add.constraint(port, type = "return", name = "mean", return_target = vec[i])
eff.port <- add.objective(eff.port, type = "risk", name = "var")
eff.port <- optimize.portfolio(returns.data, eff.port, optimize_method = "ROI")
eff.frontier$Risk[i] <- sqrt(t(eff.port$weights) %*% covMat %*% eff.port$weights)
eff.frontier$Return[i] <- eff.port$weights %*% meanReturns
eff.frontier$Sharperatio[i] <- eff.port$Return[i] / eff.port$Risk[i]
frontier.weights[i,] = eff.port$weights
print(paste(round(i/length(vec) * 100, 0), "% done..."))
}
for(i in 1:length(vec)){
eff.port <- add.constraint(port, type = "return", name = "mean", return_target = vec[i])
eff.port <- add.objective(eff.port, type = "risk", name = "var")
eff.port <- optimize.portfolio(returns.data, eff.port, optimize_method = "ROI")
eff.frontier$Risk[i] <- sqrt(t(eff.port$weights) %*% covMat %*% eff.port$weights)
eff.frontier$Return[i] <- eff.port$weights %*% meanReturns
eff.frontier$Sharperatio[i] <- eff.port$Return[i] / eff.port$Risk[i]
frontier.weights[i,] = eff.port$weights
print(paste(round(i/length(vec) * 100, 0), "% done..."))
}
install.packages(library(iterators))
install.packages(library(iterators))
install.packages(library(iterators))
install.packages(library(iterators))
install.packages(library(iterators))
install.packages(library(iterators))
install.packages("ROI")
install.packages("ROI.plugin.quadprog")
install.packages(ROI.plugin.glpk)
install.packages("ROI.plugin.glpk")
library(PortfolioAnalytics)
library(quantmod)
library(PerformanceAnalytics)
library(zoo)
library(plotly)
library(ROI)
library(ROI.plugin.quadprog)
library(ROI.plugin.glpk)
for(i in 1:length(vec)){
eff.port <- add.constraint(port, type = "return", name = "mean", return_target = vec[i])
eff.port <- add.objective(eff.port, type = "risk", name = "var")
eff.port <- optimize.portfolio(returns.data, eff.port, optimize_method = "ROI")
eff.frontier$Risk[i] <- sqrt(t(eff.port$weights) %*% covMat %*% eff.port$weights)
eff.frontier$Return[i] <- eff.port$weights %*% meanReturns
eff.frontier$Sharperatio[i] <- eff.port$Return[i] / eff.port$Risk[i]
frontier.weights[i,] = eff.port$weights
print(paste(round(i/length(vec) * 100, 0), "% done..."))
}
getSymbols(c("SPY", "IWM", "EEM", "EFA", "GDX", "IEF"))
prices.data <- merge.zoo(SPY[,6], IWM[,6], EEM[,6], EFA[,6], GDX[,6], IEF[,6])
returns.data <- CalculateReturns(prices.data)
returns.data <- na.omit(returns.data)
colnames(returns.data) <- c("SPY", "IWM", "EEM", "EFA", "GDX", "IEF")
meanReturns <- colMeans(returns.data)
covMat <- cov(returns.data)
port <- portfolio.spec(assets = c("SPY", "IWM", "EEM", "EFA", "GDX", "IEF"))
port <- add.constraint(port, type = "box", min = 0.05, max = 0.8)
port <- add.constraint(portfolio = port, type = "full_investment")
rportfolios <- random_portfolios(port, permutations = 5000, rp_method = "sample")
minvar.port <- add.objective(port, type = "risk", name = "var")
minvar.opt <- optimize.portfolio(returns.data, minvar.port, optimize_method = "random", rp = rportfolios)
maxret.port <- add.objective(port, type = "return", name = "mean")
maxret.opt <- optimize.portfolio(returns.data, maxret.port, optimize_method = "random", rp = rportfolios)
minret <- 0.06/100
maxret <- maxret.opt$weights %*% meanReturns
vec <- seq(minret, maxret, length.out = 100)
ff.frontier <- data.frame(Risk = rep(NA, length(vec)),
Return = rep(NA, length(vec)),
SharpeRatio = rep(NA, length(vec)))
frontier.weights <- mat.or.vec(nr = length(vec), nc = ncol(returns.data))
colnames(frontier.weights) <- colnames(returns.data)
for(i in 1:length(vec)){
eff.port <- add.constraint(port, type = "return", name = "mean", return_target = vec[i])
eff.port <- add.objective(eff.port, type = "risk", name = "var")
eff.port <- optimize.portfolio(returns.data, eff.port, optimize_method = "ROI")
eff.frontier$Risk[i] <- sqrt(t(eff.port$weights) %*% covMat %*% eff.port$weights)
eff.frontier$Return[i] <- eff.port$weights %*% meanReturns
eff.frontier$Sharperatio[i] <- eff.port$Return[i] / eff.port$Risk[i]
frontier.weights[i,] = eff.port$weights
print(paste(round(i/length(vec) * 100, 0), "% done..."))
}
feasible.sd <- apply(rportfolios, 1, function(x){
return(sqrt(matrix(x, nrow = 1) %*% covMat %*% matrix(x, ncol = 1)))
})
feasible.means <- apply(rportfolios, 1, function(x){
return(x %*% meanReturns)
})
feasible.sr <- feasible.means / feasible.sd
p <- plot_ly(x = feasible.sd, y = feasible.means, color = feasible.sr,
mode = "markers", type = "scattergl", showlegend = F,
marker = list(size = 3, opacity = 0.5,
colorbar = list(title = "Sharpe Ratio"))) %>%
add_trace(data = eff.frontier, x = Risk, y = Return, mode = "markers",
type = "scattergl", showlegend = F,
marker = list(color = "#F7C873", size = 5)) %>%
layout(title = "Random Portfolios with Plotly",
yaxis = list(title = "Mean Returns", tickformat = ".2%"),
xaxis = list(title = "Standard Deviation", tickformat = ".2%"),
plot_bgcolor = "#434343",
paper_bgcolor = "#F8F8F8",
annotations = list(
list(x = 0.4, y = 0.75,
ax = -30, ay = -30,
text = "Efficient frontier",
font = list(color = "#F6E7C1", size = 15),
arrowcolor = "white")
))
frontier.weights.melt <- reshape2::melt(frontier.weights)
q <- plot_ly(frontier.weights.melt, x = Var1, y = value, group = Var2, type = "bar") %>%
layout(title = "Portfolio weights across frontier", barmode = "stack",
xaxis = list(title = "Index"),
yaxis = list(title = "Weights(%)", tickformat = ".0%"))
View(ff.frontier)
eff.frontier <- data.frame(Risk = rep(NA, length(vec)),
Return = rep(NA, length(vec)),
SharpeRatio = rep(NA, length(vec)))
frontier.weights <- mat.or.vec(nr = length(vec), nc = ncol(returns.data))
colnames(frontier.weights) <- colnames(returns.data)
View(ff.frontier)
for(i in 1:length(vec)){
eff.port <- add.constraint(port, type = "return", name = "mean", return_target = vec[i])
eff.port <- add.objective(eff.port, type = "risk", name = "var")
eff.port <- optimize.portfolio(returns.data, eff.port, optimize_method = "ROI")
eff.frontier$Risk[i] <- sqrt(t(eff.port$weights) %*% covMat %*% eff.port$weights)
eff.frontier$Return[i] <- eff.port$weights %*% meanReturns
eff.frontier$Sharperatio[i] <- eff.port$Return[i] / eff.port$Risk[i]
frontier.weights[i,] = eff.port$weights
print(paste(round(i/length(vec) * 100, 0), "% done..."))
}
feasible.sd <- apply(rportfolios, 1, function(x){
return(sqrt(matrix(x, nrow = 1) %*% covMat %*% matrix(x, ncol = 1)))
})
feasible.means <- apply(rportfolios, 1, function(x){
return(x %*% meanReturns)
})
feasible.sr <- feasible.means / feasible.sd
p <- plot_ly(x = feasible.sd, y = feasible.means, color = feasible.sr,
mode = "markers", type = "scattergl", showlegend = F,
marker = list(size = 3, opacity = 0.5,
colorbar = list(title = "Sharpe Ratio"))) %>%
add_trace(data = eff.frontier, x = Risk, y = Return, mode = "markers",
type = "scattergl", showlegend = F,
marker = list(color = "#F7C873", size = 5)) %>%
layout(title = "Random Portfolios with Plotly",
yaxis = list(title = "Mean Returns", tickformat = ".2%"),
xaxis = list(title = "Standard Deviation", tickformat = ".2%"),
plot_bgcolor = "#434343",
paper_bgcolor = "#F8F8F8",
annotations = list(
list(x = 0.4, y = 0.75,
ax = -30, ay = -30,
text = "Efficient frontier",
font = list(color = "#F6E7C1", size = 15),
arrowcolor = "white")
))
frontier.weights.melt <- reshape2::melt(frontier.weights)
q <- plot_ly(frontier.weights.melt, x = Var1, y = value, group = Var2, type = "bar") %>%
layout(title = "Portfolio weights across frontier", barmode = "stack",
xaxis = list(title = "Index"),
yaxis = list(title = "Weights(%)", tickformat = ".0%"))
View(frontier.weights)
View(eff.frontier)
View(eff.frontier)
plot(x=tmp1.StdDev, y=tmp1.mean, col="gray", main="Random Portfolio Methods", ylab="mean", xlab="StdDev")
library(PortfolioAnalytics)
library(quantmod)
library(PerformanceAnalytics)
library(zoo)
library(plotly)
library(ROI)
library(ROI.plugin.quadprog)
library(ROI.plugin.glpk)
getSymbols(c("SPY", "IWM", "EEM", "EFA", "GDX", "IEF"))
prices.data <- merge.zoo(SPY[,6], IWM[,6], EEM[,6], EFA[,6], GDX[,6], IEF[,6])
returns.data <- CalculateReturns(prices.data)
returns.data <- na.omit(returns.data)
colnames(returns.data) <- c("SPY", "IWM", "EEM", "EFA", "GDX", "IEF")
meanReturns <- colMeans(returns.data)
covMat <- cov(returns.data)
port <- portfolio.spec(assets = c("SPY", "IWM", "EEM", "EFA", "GDX", "IEF"))
port <- add.constraint(port, type = "box", min = 0.05, max = 0.8)
port <- add.constraint(portfolio = port, type = "full_investment")
rportfolios <- random_portfolios(port, permutations = 5000, rp_method = "sample")
minvar.port <- add.objective(port, type = "risk", name = "var")
minvar.opt <- optimize.portfolio(returns.data, minvar.port, optimize_method = "random", rp = rportfolios)
maxret.port <- add.objective(port, type = "return", name = "mean")
maxret.opt <- optimize.portfolio(returns.data, maxret.port, optimize_method = "random", rp = rportfolios)
minret <- 0.03/100
maxret <- maxret.opt$weights %*% meanReturns
vec <- seq(minret, maxret, length.out = 100)
eff.frontier <- data.frame(Risk = rep(NA, length(vec)),
Return = rep(NA, length(vec)),
SharpeRatio = rep(NA, length(vec)))
frontier.weights <- mat.or.vec(nr = length(vec), nc = ncol(returns.data))
colnames(frontier.weights) <- colnames(returns.data)
for(i in 1:length(vec)){
eff.port <- add.constraint(port, type = "return", name = "mean", return_target = vec[i])
eff.port <- add.objective(eff.port, type = "risk", name = "var")
eff.port <- optimize.portfolio(returns.data, eff.port, optimize_method = "ROI")
eff.frontier$Risk[i] <- sqrt(t(eff.port$weights) %*% covMat %*% eff.port$weights)
eff.frontier$Return[i] <- eff.port$weights %*% meanReturns
eff.frontier$Sharperatio[i] <- eff.port$Return[i] / eff.port$Risk[i]
frontier.weights[i,] = eff.port$weights
print(paste(round(i/length(vec) * 100, 0), "% done..."))
}
feasible.sd <- apply(rportfolios, 1, function(x){
return(sqrt(matrix(x, nrow = 1) %*% covMat %*% matrix(x, ncol = 1)))
})
feasible.means <- apply(rportfolios, 1, function(x){
return(x %*% meanReturns)
})
feasible.sr <- feasible.means / feasible.sd
print(port)
print(maxret.port)
print(eff.frontier)
print(feasible.means)
maxvar <- 0.10
maxrettarvar.port <- add.objective(port, type = "return", name = "mean")
maxrettarvar.opt <- optimize.portfolio(returns.data, maxrettarvar.port, optimize_method = "random", rp = rportfolios)
print(maxrettarvar.opt)
maxvar <- 0.01
> maxrettarvar.port <- add.objective(port, type = "return", name = "mean")
> maxrettarvar.opt <- optimize.portfolio(returns.data, maxrettarvar.port, optimize_method = "random", rp = rportfolios)
maxrettarvar.port <- add.objective(port, type = "return", name = "mean")
maxrettarvar.opt <- optimize.portfolio(returns.data, maxrettarvar.port, optimize_method = "random", rp = rportfolios)
print(maxrettarvar.opt)
library(readxl)
ConsBenchRetsEQLDates <- read_excel("C:/Users/Micha/Downloads/ConsBenchRetsEQLDates.xlsx",
col_types = c("date", "numeric", "numeric",
"numeric", "numeric", "numeric",
"numeric", "numeric", "numeric",
"numeric", "numeric", "numeric"))
View(ConsBenchRetsEQLDates)
library(readxl)
ConsBenchRetsEQLDates <- read_excel("C:/Users/Micha/Downloads/ConsBenchRetsEQLDates.xlsx",
col_types = c("date", "numeric", "numeric",
"numeric", "numeric", "numeric",
"numeric", "numeric", "numeric",
"numeric", "numeric", "numeric"))
BRT <- ConsBenchRetsEQLDates
View(BRT)
print(BRT[1,])
GSCI <- (BRT[,2])
print(GSCI)
print(BRT[1,])
print(BRT[,1])
printBRT
Print(BRT)
print(BRT)
colnames(BRT)
meanReturns <- BRT
covMat <- cov(BRT)
meanReturns <- colMeans(BRT)
covMat <- cov(BRT)
meanReturns(BRT[,-1])
library(PortfolioAnalytics)
library(quantmod)
library(PerformanceAnalytics)
library(zoo)
library(plotly)
library(ROI)
library(ROI.plugin.quadprog)
library(ROI.plugin.glpk)
meanReturns(BRT[,-1])
BRT.data  <- BRT
meanReturns <- colMeans(BRT.data)
covMat <- cov(BRT.data)
BRT.data  <- BRT
meanReturns <- colMeans(BRT.data[,-1])
covMat <- cov(BRT.data[,-1])
BRT.data  <- BRT[,-1]
meanReturns <- colMeans(BRT.data)
covMat <- cov(BRT.data)
BRT.data  <- BRT[,-1]
meanReturns <- colMeans(BRT.data)
covMat <- cov(BRT.data)
#ie. Isolating Benchmarks from Table
GSCI <- (BRT[,2])
USHY <- (BRT[,3])
USAGG <- (BRT[,4])
USLC <- (BRT[,5])
USMC <- (BRT[,6])
USSC <- (BRT[,7])
EAFE <- (BRT[,8])
EM <- (BRT[,9])
USRE <- (BRT[,10])
CASH <- (BRT[,11])
INTLFI <- (BRT[,12])
## Fix portfolio.spec independent variables  ##
port <- portfolio.spec(assets = c("GSCI", "USHY", "USAGG", "USLC", "USMC", "USSC", "EAFE", "EM", "USRE", "CASH", "INTLFI"))
## Adjust the Constraints if neccesary
port <- add.constraint(port, type = "box", min = 0.05, max = 0.8)
port <- add.constraint(portfolio = port, type = "full_investment")
rportfolios <- random_portfolios(port, permutations = 5000, rp_method = "sample")
minvar.port <- add.objective(port, type = "risk", name = "var")
minvar.opt <- optimize.portfolio(returns.data, minvar.port, optimize_method = "random", rp = rportfolios)
maxret.port <- add.objective(port, type = "return", name = "mean")
maxret.opt <- optimize.portfolio(returns.data, maxret.port, optimize_method = "random", rp = rportfolios)
minvar.opt <- optimize.portfolio(BRT.data, minvar.port, optimize_method = "random", rp = rportfolios)
maxret.port <- add.objective(port, type = "return", name = "mean")
maxret.opt <- optimize.portfolio(BRT.data, maxret.port, optimize_method = "random", rp = rportfolios)
View(rportfolios)
minvar.port <- add.objective(port, type = "risk", name = "var")
minvar.opt <- optimize.portfolio(BRT, minvar.port, optimize_method = "random", rp = rportfolios)
maxret.port <- add.objective(port, type = "return", name = "mean")
maxret.opt <- optimize.portfolio(BRT, maxret.port, optimize_method = "random", rp = rportfolios)
getSymbols(c("SPY", "IWM", "EEM", "EFA", "GDX", "IEF"))
prices.data <- merge.zoo(SPY[,6], IWM[,6], EEM[,6], EFA[,6], GDX[,6], IEF[,6])
returns.data <- CalculateReturns(prices.data)
returns.data <- na.omit(returns.data)
print(returns.data)
BRT.data  <- BRT[,-1]
row.names(BRT.data) <- BRT[,1]
row.names(BRT.data) <- BRT[,1]
rownames(BRT.data) <- BRT[,1]
summary(BRT.data)
print(BRT.data)
BRT.data  <- BRT[,-1]
BRT[,1] <- BRTdates
row.names(BRT.data) <- BRTdates
BRT.data  <- BRT[,-1]
BRTdates <- BRT[,1]
row.names(BRT.data) <- BRTdates
row.names(BRT.data)
BRTdates <- BRT[,1]
attributes(BRTdates)
print(BRTdates)
library(readxl)
ConsBenchRetsEQLDates <- read_excel("C:/Users/Micha/Downloads/ConsBenchRetsEQLDates.xlsx",
col_types = c("date", "numeric", "numeric",
"numeric", "numeric", "numeric",
"numeric", "numeric", "numeric",
"numeric", "numeric", "numeric"))
BRT <- ConsBenchRetsEQLDates
View(BRT)
print(BRT[1,])
dates <- BRT$date
values <- BRT[,-1]
library(PortfolioAnalytics)
library(quantmod)
library(PerformanceAnalytics)
library(zoo)
library(plotly)
library(ROI)
library(ROI.plugin.quadprog)
library(ROI.plugin.glpk)
BRT_ts <- ts(BRT[,-1], start=c(2000, 2), end=c(2017, 8), frequency=12)
#ie. Isolating Benchmarks from Table
GSCI <- (BRT_ts[,1])
USHY <- (BRT_ts[,2])
USAGG <- (BRT_ts[,3])
USLC <- (BRT_ts[,4])
USMC <- (BRT_ts[,5])
USSC <- (BRT_ts[,6])
EAFE <- (BRT_ts[,7])
EM <- (BRT_ts[,8])
USRE <- (BRT_ts[,9])
CASH <- (BRT_ts[,10])
INTLFI <- (BRT_ts[,11])
## Starting Code of Optimizer ###
meanReturns <- colMeans(BRT_ts)
covMat <- cov(BRT_ts)
port <- portfolio.spec(assets = c("GSCI", "USHY", "USAGG", "USLC", "USMC", "USSC", "EAFE", "EM", "USRE", "CASH", "INTLFI"))
port <- add.constraint(portfolio = port, type = "full_investment")
port <- add.constraint(port, type = "box",
min=c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
max=c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1))
########### (GSCI, USHY, USAGG,  USLC, USMC, USSC, EAFE,  EM,  USRE, CASH, INTLFI)
weights <- c(0.00, 0.05,  0.000, 0.25, 0.16, 0.17, 0.15, 0.10, 0.05, 0.02, 0.05)
Ann.var <- (sqrt(12)*var.portfolio(BRT_ts, weights))
print(Ann.var)
StdDev(BRT_ts)
StdDev(BRT_ts, weights=weights)
weights <- c(0.00, 0.05,  0.000, 0.25, 0.16, 0.17, 0.15, 0.10, 0.05, 0.02, 0.05)
Ann.var <- (sqrt(12)*(StdDev(BRT_ts, weights=weights))
)
weights <- c(0.00, 0.05,  0.000, 0.25, 0.16, 0.17, 0.15, 0.10, 0.05, 0.02, 0.05)
Ann.var <- (sqrt(12)*(StdDev(BRT_ts, weights=weights)))
print(Ann.var)
weights <- c(0.00, 0.05,  0.000, 0.25, 0.16, 0.17, 0.15, 0.10, 0.05, 0.02, 0.05)
Ann.var <- (sqrt(12)*(StdDev(BRT_ts, weights=weights)))
print(Ann.var)
weights85 <- c(0.00, 0.05,  0.00, 0.25, 0.20, 0.20, 0.15, 0.10, 0.03, 0.02, 0.00)
weights75 <- c(0.00, 0.10,  0.00, 0.20, 0.16, 0.17, 0.15, 0.10, 0.05, 0.02, 0.05)
weights65 <- c(0.00, 0.10,  0.10, 0.18, 0.13, 0.13, 0.13, 0.09, 0.07, 0.02, 0.05)
weights55 <- c(0.00, 0.10,  0.20, 0.15, 0.07, 0.08, 0.12, 0.08, 0.07, 0.03, 0.10)
weights45 <- c(0.00, 0.10,  0.35, 0.12, 0.06, 0.07, 0.10, 0.05, 0.06, 0.04, 0.05)
weights35 <- c(0.00, 0.10,  0.45, 0.10, 0.00, 0.05, 0.10, 0.05, 0.05, 0.05, 0.05)
weights25 <- c(0.00, 0.10,  0.60, 0.08, 0.00, 0.00, 0.07, 0.00, 0.00, 0.05, 0.10)
Ann.var85 <- (sqrt(12)*(StdDev(BRT_ts, weights=weights85)))
Ann.var75 <- (sqrt(12)*(StdDev(BRT_ts, weights=weights75)))
Ann.var65 <- (sqrt(12)*(StdDev(BRT_ts, weights=weights65)))
Ann.var55 <- (sqrt(12)*(StdDev(BRT_ts, weights=weights55)))
Ann.var45 <- (sqrt(12)*(StdDev(BRT_ts, weights=weights45)))
Ann.var35 <- (sqrt(12)*(StdDev(BRT_ts, weights=weights35)))
Ann.var25 <- (sqrt(12)*(StdDev(BRT_ts, weights=weights25)))
print(Ann.var85)
print(Ann.var75)
print(Ann.var65)
print(Ann.var55)
print(Ann.var45)
print(Ann.var35)
print(Ann.var25)
weights75 <- c(0.00, 0.05,  0.05, 0.20, 0.16, 0.17, 0.15, 0.10, 0.05, 0.02, 0.05)
Ann.var75 <- (sqrt(12)*(StdDev(BRT_ts, weights=weights75)))
print(Ann.var75)
setwd("~/GitHub/Finance_R_Files/R Scripts")
getwd()
library(readxl)
library(PortfolioAnalytics)
library(quantmod)
library(PerformanceAnalytics)
library(zoo)
library(plotly)
library(ROI)
library(ROI.plugin.quadprog)
library(ROI.plugin.glpk)
####################################################################################################################################################
############# Step 1 #############
### Import Holdings Returns (This uses daily price returns and is suitable for short term return analysis)
Hrets <- read_excel("C:/Users/Micha/Downloads/ModelTR.xlsx")
head(Hrets)
Hrets.df <- (Hrets)
R <- xts(Hrets[-1], Hrets.df$Period)
weights <- read_excel("C:/Users/Micha/Downloads/Model Alloc Import.xlsx")
str(weights)
weights <- as.numeric(weights)
wMatrix <- as.matrix(weights[,-1])
str(wMatrix)
w85 <- wMatrix[1,]
w75 <- wMatrix[2,]
w65 <- wMatrix[3,]
w55 <- wMatrix[4,]
w55CAM <- wMatrix[5,]
w45 <- wMatrix[6,]
w45CAM <- wMatrix[7,]
w35 <- wMatrix[8,]
w35CAM <- wMatrix[9,]
w35NatM <- wMatrix[10,]
w25 <- wMatrix[11,]
w25CAM <- wMatrix[12,]
r85 <- Return.portfolio(R, weights = w85, wealth.index = FALSE, contribution = FALSE, geometric = TRUE,
rebalance_on = c(NA), value = 1, verbose = FALSE)
r75 <- Return.portfolio(R, weights = w75, wealth.index = FALSE, contribution = FALSE, geometric = TRUE,
rebalance_on = c(NA), value = 1, verbose = FALSE)
r65 <- Return.portfolio(R, weights = w65, wealth.index = FALSE, contribution = FALSE, geometric = TRUE,
rebalance_on = c(NA), value = 1, verbose = FALSE)
r55 <- Return.portfolio(R, weights = w55, wealth.index = FALSE, contribution = FALSE, geometric = TRUE,
rebalance_on = c(NA), value = 1, verbose = FALSE)
r55CAM <- Return.portfolio(R, weights = w55CAM, wealth.index = FALSE, contribution = FALSE, geometric = TRUE,
rebalance_on = c(NA), value = 1, verbose = FALSE)
r45 <- Return.portfolio(R, weights = w45, wealth.index = FALSE, contribution = FALSE, geometric = TRUE,
rebalance_on = c(NA), value = 1, verbose = FALSE)
r45CAM <- Return.portfolio(R, weights = w45CAM, wealth.index = FALSE, contribution = FALSE, geometric = TRUE,
rebalance_on = c(NA), value = 1, verbose = FALSE)
r35 <- Return.portfolio(R, weights = w35, wealth.index = FALSE, contribution = FALSE, geometric = TRUE,
rebalance_on = c(NA), value = 1, verbose = FALSE)
r35CAM <- Return.portfolio(R, weights = w35CAM, wealth.index = FALSE, contribution = FALSE, geometric = TRUE,
rebalance_on = c(NA), value = 1, verbose = FALSE)
r35NatM <- Return.portfolio(R, weights = w35NatM, wealth.index = FALSE, contribution = FALSE, geometric = TRUE,
rebalance_on = c(NA), value = 1, verbose = FALSE)
r25 <- Return.portfolio(R, weights = w25, wealth.index = FALSE, contribution = FALSE, geometric = TRUE,
rebalance_on = c(NA), value = 1, verbose = FALSE)
r25CAM <- Return.portfolio(R, weights = w25CAM, wealth.index = FALSE, contribution = FALSE, geometric = TRUE,
rebalance_on = c(NA), value = 1, verbose = FALSE)
NAModelRets <- cbind(r85,r75,r65,r55,r55CAM,r45,r45CAM,r35,r35CAM,r35NatM,r25,r25CAM)
head(NAModelRets)
colnames(NAModelRets) <- c("NA85","NA75","NA65","NA55","NA55CAM","NA45","NA45CAM","NA35","NA35CAM","NA35NatM","NA25","NA25CAM")
head(NAModelRets)
CNAMRets <- Return.cumulative(NAModelRets, geometric = TRUE)
head(CNAMRets)
RetTable <- table.CalendarReturns(NAModelRets, digits = 4, as.perc = TRUE)
head(RetTable)
library(xlsx)
install.packages("xlsx")
getwd()
write.xlsx(RetTable, "c:/Users/Micha/Downloads/RetTable.xlsx")
library(xlsx)
View(RetTable)
library("rJava", lib.loc="~/R/win-library/3.4")
write.xlsx2(RetTable, "c:/Users/Micha/Downloads/RetTable.xlsx")
library(rJava)
library(rJava)
library(xlsx)
write.xlsx2(RetTable, "c:/Users/Micha/Downloads/RetTable.xlsx")
RollCNAM <- apply.rolling(NAModelRets, FUN = Return.cumulative)
str(NAModelRets)
RollCNAM <- apply.rolling(NAModelRets, 825, FUN = Return.cumulative)
head(RollCNAM)
Cr85 <- apply.rolling(r85, 825, FUN = Return.cumulative)
head(Cr85)
Cr85 <- apply.rolling(r85, 30, FUN = Return.cumulative)
View(Cr85)
chart.CumReturns(NAModelRets,wealth.index = False, geometric = True)
chart.CumReturns(NAModelRets,wealth.index = FALSE, geometric = TRUE)
chart.CumReturns(r85,wealth.index = FALSE, geometric = TRUE)
VaR(r85, p=0.95)
